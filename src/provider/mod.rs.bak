//! Subscription Providers (Proxy and Rule)
//!
//! This module will be fully implemented in Phase 3.

mod fetcher;
mod healthcheck;
mod proxy;
mod rule;

pub use fetcher::Fetcher;
pub use healthcheck::HealthCheck;
pub use proxy::ProxySetProvider;
pub use rule::RuleProvider;

use crate::outbound::OutboundProxy;
use crate::{Error, Result};
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

/// Provider type
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ProviderType {
    Proxy,
    Rule,
}

/// Vehicle type (how data is loaded)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
pub enum VehicleType {
    HTTP,
    File,
    Inline,
    Compatible,
}

impl std::fmt::Display for VehicleType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            VehicleType::HTTP => write!(f, "HTTP"),
            VehicleType::File => write!(f, "File"),
            VehicleType::Inline => write!(f, "Inline"),
            VehicleType::Compatible => write!(f, "Compatible"),
        }
    }
}

/// Subscription information parsed from headers
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubscriptionInfo {
    /// Upload bytes used
    pub upload: u64,
    /// Download bytes used
    pub download: u64,
    /// Total bytes available
    pub total: u64,
    /// Expiration timestamp (Unix epoch)
    pub expire: u64,
}

impl SubscriptionInfo {
    /// Parse from Subscription-Userinfo header
    ///
    /// Format: "upload=xxx; download=xxx; total=xxx; expire=xxx"
    pub fn parse(header: &str) -> Option<Self> {
        let mut info = SubscriptionInfo {
            upload: 0,
            download: 0,
            total: 0,
            expire: 0,
        };

        for part in header.split(';') {
            let part = part.trim();
            if let Some((key, value)) = part.split_once('=') {
                let value: u64 = value.trim().parse().unwrap_or(0);
                match key.trim().to_lowercase().as_str() {
                    "upload" => info.upload = value,
                    "download" => info.download = value,
                    "total" => info.total = value,
                    "expire" => info.expire = value,
                    _ => {}
                }
            }
        }

        Some(info)
    }
}

/// Trait for proxy providers
#[async_trait]
pub trait ProxyProvider: Send + Sync {
    /// Provider name
    fn name(&self) -> &str;

    /// Provider type
    fn provider_type(&self) -> ProviderType;

    /// Vehicle type (how proxies are loaded)
    fn vehicle_type(&self) -> VehicleType;

    /// Get proxies
    fn proxies(&self) -> Vec<Arc<dyn OutboundProxy>>;

    /// Proxy count
    fn count(&self) -> usize;

    /// Update proxies (fetch from source)
    async fn update(&self) -> Result<()>;

    /// Initial load
    async fn initial(&self) -> Result<()>;

    /// Health check all proxies
    async fn health_check(&self);

    /// Touch (update last access time)
    fn touch(&self);

    /// Get health check URL
    fn health_check_url(&self) -> &str;

    /// Last update time
    fn updated_at(&self) -> Option<DateTime<Utc>>;

    /// Subscription info (for HTTP providers)
    fn subscription_info(&self) -> Option<&SubscriptionInfo>;

    /// Close provider
    async fn close(&self);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_subscription_info_parse() {
        let header = "upload=1234; download=5678; total=10000000; expire=1704067200";
        let info = SubscriptionInfo::parse(header).unwrap();

        assert_eq!(info.upload, 1234);
        assert_eq!(info.download, 5678);
        assert_eq!(info.total, 10000000);
        assert_eq!(info.expire, 1704067200);
    }

    #[test]
    fn test_vehicle_type_display() {
        assert_eq!(VehicleType::HTTP.to_string(), "HTTP");
        assert_eq!(VehicleType::File.to_string(), "File");
    }
}
